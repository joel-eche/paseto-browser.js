{"version":3,"file":"paseto.v4.public.js","sources":["../lib/util.js","../lib/paseto.v4.public.js"],"sourcesContent":["import {timingSafeEqual, randomBytes} from 'crypto'\r\n\r\nconst byteToHex = [];\r\nfor (let n = 0; n <= 0xff; ++n)\r\n{\r\n    const hexOctet = n.toString(16).padStart(2, \"0\");\r\n    byteToHex.push(hexOctet);\r\n}\r\n\r\nconst b64u_chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'\r\nconst b64u_lookup = new Uint8Array(256);\r\nfor (let i = 0; i < b64u_chars.length; i++) {\r\n    b64u_lookup[b64u_chars.charCodeAt(i)] = i\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} base64\r\n * @param {boolean} as_uint8array\r\n * @returns {string|Uint8Array}\r\n */\r\nexport function b64u_dec(base64, as_uint8array = false) {\r\n    let bufferLength = base64.length * 0.75,\r\n        len = base64.length, i, p = 0,\r\n        encoded1, encoded2, encoded3, encoded4;\r\n\r\n    const bytes = new Uint8Array(bufferLength)\r\n    for (i = 0; i < len; i+=4) {\r\n        encoded1 = b64u_lookup[base64.charCodeAt(i)]\r\n        encoded2 = b64u_lookup[base64.charCodeAt(i+1)]\r\n        encoded3 = b64u_lookup[base64.charCodeAt(i+2)]\r\n        encoded4 = b64u_lookup[base64.charCodeAt(i+3)]\r\n\r\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4)\r\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2)\r\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63)\r\n    }\r\n    if (as_uint8array) {\r\n        return bytes\r\n    }\r\n    return (new TextDecoder()).decode(bytes)\r\n}\r\n\r\n/**\r\n *\r\n * @ref https://stackoverflow.com/q/12710001\r\n * @param {Uint8Array} bytes\r\n * @returns {string}\r\n */\r\nexport function b64u_enc(bytes) {\r\n    let i, len = bytes.length, base64 = \"\";\r\n    for (i = 0; i < len; i+=3) {\r\n        base64 += b64u_chars[bytes[i] >> 2];\r\n        base64 += b64u_chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\r\n        base64 += b64u_chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\r\n        base64 += b64u_chars[bytes[i + 2] & 63];\r\n    }\r\n    if ((len % 3) === 2) {\r\n        return base64.substring(0, base64.length - 1);\r\n    } else if (len % 3 === 1) {\r\n        return base64.substring(0, base64.length - 2);\r\n    }\r\n    return base64\r\n}\r\n\r\n/**\r\n *\r\n * @param {Uint8Array} mixed\r\n * @returns {string}\r\n */\r\nexport function from_u8(mixed) {\r\n    if (typeof mixed === 'string') {\r\n        return mixed\r\n    } else if (mixed instanceof Uint8Array) {\r\n        return (new TextDecoder()).decode(mixed)\r\n    }\r\n    throw new Error(`Unsupported type: ${typeof mixed}`)\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} hexString\r\n * @returns {Uint8Array}\r\n */\r\nexport function hex_to_u8(hexString) {\r\n    if (hexString.length === 0) {\r\n        return new Uint8Array([])\r\n    }\r\n    if ((hexString.length & 1) === 1) {\r\n        hexString = '0' + hexString\r\n    }\r\n    const buf = new Uint8Array(hexString.length >>> 1)\r\n    for (let i = 0, j = 0; i < hexString.length; i += 2, j++) {\r\n        buf[j] = parseInt(hexString.slice(i, i + 2), 16)\r\n    }\r\n    return buf\r\n}\r\n\r\n/**\r\n *\r\n * @param {number} num\r\n * @returns {Uint8Array}\r\n */\r\nexport function le32(num) {\r\n    needs(Number.isSafeInteger(num), 'Number too large for JavaScript to safely process')\r\n    const low =  (num & 0xffffffff)\r\n    const out = new Uint8Array(4)\r\n    out[0] =  low          & 0xff\r\n    out[1] =  (low >>>  8) & 0xff\r\n    out[2] =  (low >>> 16) & 0xff\r\n    out[3] =  (low >>> 24) & 0xff\r\n    return out\r\n}\r\n\r\n/**\r\n *\r\n * @param {number} num\r\n * @returns {Uint8Array}\r\n */\r\nexport function le64(num) {\r\n    needs(Number.isSafeInteger(num), 'Number too large for JavaScript to safely process')\r\n\r\n    const high = (num / 0x100000000)|0\r\n    const low =  (num & 0x0ffffffff)\r\n    const out = new Uint8Array(8)\r\n    out[0] =  low          & 0xff\r\n    out[1] =  (low >>>  8) & 0xff\r\n    out[2] =  (low >>> 16) & 0xff\r\n    out[3] =  (low >>> 24) & 0xff\r\n    out[4] = high          & 0xff\r\n    out[5] = (high >>>  8) & 0xff\r\n    out[6] = (high >>> 16) & 0xff\r\n    out[7] = (high >>> 24) & 0xff\r\n    return out\r\n}\r\n\r\n/**\r\n *\r\n * @param {Uint8Array} buf\r\n * @returns {number}\r\n */\r\nexport function load32le(buf) {\r\n    return buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24)\r\n}\r\n\r\n/**\r\n *\r\n * @param {Uint8Array} ctx\r\n * @param {number} offset\r\n * @returns {number}\r\n */\r\nexport function readInt32BE(ctx, offset) {\r\n    return load32le(ctx.slice(offset, offset + 4))\r\n}\r\n\r\n/**\r\n *\r\n * @param {Uint8Array} output\r\n * @param {number} num\r\n * @param {number} start\r\n * @returns {*}\r\n */\r\nexport function write32le(output, num, start) {\r\n    if (start >= output.length)\r\n        return output;\r\n    output[start    ] = (num         & 0xff)\r\n    if (start + 1 >= output.length)\r\n        return output;\r\n    output[start + 1] = ((num >>>  8) & 0xff)\r\n    if (start + 2 >= output.length)\r\n        return output;\r\n    output[start + 2] = ((num >>> 16) & 0xff)\r\n    if (start + 3 >= output.length)\r\n        return output;\r\n    output[start + 3] = ((num >>> 24) & 0xff)\r\n    return output\r\n}\r\n\r\n/**\r\n *\r\n * @param {boolean} condition\r\n * @param {string} message\r\n */\r\nexport function needs(condition, message= 'An unknown error occurred') {\r\n    if (!condition) throw new Error(message)\r\n}\r\n\r\n/**\r\n *\r\n * @param {Uint8Array|string} pieces\r\n * @returns {Uint8Array}\r\n * @constructor\r\n */\r\nexport function PAE(...pieces) {\r\n    let out = le64(pieces.length)\r\n    for (let piece of pieces) {\r\n        let p = to_u8(piece)\r\n        needs(p instanceof Uint8Array, 'Only string and Uint8Array is allowed')\r\n        let len = le64(p.length)\r\n        out = new Uint8Array([ ...out, ...len, ...p ])\r\n    }\r\n    return out\r\n}\r\n\r\n/**\r\n *\r\n * @param {number }num\r\n * @returns {Uint8Array}\r\n */\r\nexport function random_bytes(num = 0) {\r\n    const buf = new Uint8Array(num)\r\n    if (typeof window !== 'undefined') {\r\n        if (window.crypto && window.crypto.getRandomValues) {\r\n            window.crypto.getRandomValues(buf)\r\n            return buf\r\n        }\r\n        if (typeof window.msCrypto === 'object' && typeof window.msCrypto.getRandomValues === 'export function') {\r\n            window.msCrypto.getRandomValues(buf)\r\n            return buf\r\n        }\r\n    }\r\n    if (randomBytes) {\r\n        const rand = randomBytes(num)\r\n        buf.set(rand, 0)\r\n        return buf\r\n    }\r\n    throw new Error('No secure random number generator available')\r\n}\r\n\r\n/**\r\n *\r\n * @param {string|number|Uint8Array} mixed\r\n * @param {boolean} tolerate_integers\r\n * @returns {Uint8Array}\r\n */\r\nexport function to_u8(mixed, tolerate_integers = false) {\r\n    if (mixed instanceof Uint8Array) {\r\n        return mixed\r\n    } else if (typeof mixed === 'string') {\r\n        return (new TextEncoder()).encode(mixed)\r\n    } else if (mixed instanceof Number && tolerate_integers) {\r\n        return le64(mixed)\r\n    }\r\n    throw new Error(`Unsupported type: ${typeof mixed}`)\r\n}\r\n\r\n/**\r\n *\r\n * @param {Uint8Array} arrs\r\n * @returns {Uint8Array}\r\n */\r\nexport function u8_concat(...arrs) {\r\n    let len = 0\r\n    for (const arr of arrs) {\r\n        if (arr.length)\r\n            len += arr.length\r\n    }\r\n    const u8 = new Uint8Array(len)\r\n    let start = 0\r\n    for (const arr of arrs) {\r\n        u8.set(arr, start)\r\n        start += arr.length\r\n    }\r\n    return u8\r\n}\r\n\r\n/**\r\n *\r\n * @param {Uint8Array} a\r\n * @param {Uint8Array} b\r\n * @returns {boolean}\r\n */\r\nexport function u8_equal(a, b) {\r\n    if (typeof timingSafeEqual === 'undefined') {\r\n        needs(a instanceof Uint8Array, 'Must be Uint8Array')\r\n        needs(b instanceof Uint8Array, 'Must be Uint8Array')\r\n        if (a.length !== b.length) {\r\n            return false\r\n        }\r\n        let d = 0\r\n        for (let i = 0; i < a.length; i++) {\r\n            d |= (a[i] ^ b[i])\r\n        }\r\n        return d === 0\r\n    }\r\n    return timingSafeEqual(to_u8(a), to_u8(b))\r\n}\r\n\r\n/**\r\n *\r\n * @param {Uint8Array} uint8arr\r\n * @returns {string}\r\n */\r\nexport function u8_to_hex(uint8arr) {\r\n    const output = []\r\n    for (let i = 0; i < uint8arr.length; i++) {\r\n        output.push(byteToHex[uint8arr[i]])\r\n    }\r\n    return output.join('')\r\n}\r\n","import * as nacl from 'tweetnacl'\r\nimport { b64u_dec, b64u_enc, from_u8, needs, PAE, to_u8, u8_concat, u8_equal } from './util.js'\r\n\r\nconst V4_PUBLIC = 'v4.public.'\r\nconst V4_PUBLIC_U8 = new TextEncoder().encode(V4_PUBLIC)\r\n\r\nexport class PasetoV4Public {\r\n    constructor(pk, sk = null) {\r\n        needs(pk instanceof Uint8Array, \"Input must be a Uint8Array\")\r\n        needs(pk.length === 32, \"Public Key must be 32 bytes\")\r\n        this.pk = pk\r\n        if (sk) {\r\n            needs(sk instanceof Uint8Array, \"Input must be a Uint8Array\")\r\n            needs(sk.length === 64, \"Secret Key must be 64 bytes\")\r\n            this.sk = sk\r\n        } else {\r\n            this.sk = null\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns {Uint8Array}\r\n     */\r\n    getSecretKey() {\r\n        return this.sk\r\n    }\r\n\r\n    /**\r\n     * @returns {Uint8Array}\r\n     */\r\n    getPublicKey() {\r\n        return this.pk\r\n    }\r\n\r\n    /**\r\n     * @returns {PasetoV4Public}\r\n     */\r\n    static generate() {\r\n        const keypair = nacl.default.sign.keyPair()\r\n        return new PasetoV4Public(keypair.publicKey, keypair.secretKey)\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} token\r\n     * @param {Uint8Array} expected\r\n     * @returns {Promise<boolean>}\r\n     */\r\n    async assertFooter(token, expected) {\r\n        const pieces = token.split('.')\r\n        needs(pieces.length === 4, \"No footer provided\")\r\n        const stored = b64u_dec(pieces[3], expected instanceof Uint8Array)\r\n        return u8_equal(stored, expected)\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} token\r\n     * @param {boolean} as_object\r\n     * @returns {string|Uint8Array|object}\r\n     */\r\n    static getFooter(token, as_object = false) {\r\n        const pieces = token.split('.')\r\n        needs(pieces.length === 4, \"No footer provided\")\r\n        const stored = b64u_dec(pieces[3], as_object)\r\n        if (as_object) {\r\n            return JSON.parse(from_u8(stored))\r\n        }\r\n        return stored\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} token\r\n     * @param {string} implicit\r\n     * @returns {Promise<object>}\r\n     */\r\n    async decode(token, implicit = '') {\r\n        return JSON.parse(await this.verify(token, implicit))\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string|object} claims\r\n     * @param {string|object} footer\r\n     * @param {string} implicit\r\n     * @returns {Promise<string>}\r\n     */\r\n    async encode(claims, footer = '', implicit = '') {\r\n        needs(this.sk, 'Cannot sign: No secret key was provided')\r\n        if (typeof footer === 'object') {\r\n            footer = JSON.stringify(footer)\r\n        }\r\n        if (typeof footer === 'string') {\r\n            footer = to_u8(footer)\r\n        }\r\n        return this.sign(JSON.stringify(claims), footer, implicit)\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string|Uint8Array} message\r\n     * @param {string} footer\r\n     * @param {string} implicit\r\n     * @returns {Promise<string>}\r\n     */\r\n    async sign(message, footer = '', implicit = '') {\r\n        needs(this.sk, 'Cannot sign: No secret key was provided')\r\n\r\n        const msg_u8 = to_u8(message)\r\n\r\n        const m2 = PAE(\r\n            V4_PUBLIC_U8,\r\n            msg_u8,\r\n            to_u8(footer),\r\n            to_u8(implicit)\r\n        )\r\n        const sig = nacl.default.sign.detached(m2, this.sk)\r\n        const payload = b64u_enc(u8_concat(msg_u8, sig))\r\n        if (footer.length > 0) {\r\n            return [V4_PUBLIC.slice(0, 9), payload, b64u_enc(footer)].join('.')\r\n        }\r\n        return [V4_PUBLIC.slice(0, 9), payload].join('.')\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} token\r\n     * @param {string} implicit\r\n     * @returns {Promise<string>}\r\n     */\r\n    async verify(token, implicit = '') {\r\n        const {msg, sig, footer} = await this.decompose(token)\r\n        const m2 = PAE(\r\n            V4_PUBLIC_U8,\r\n            msg,\r\n            to_u8(footer),\r\n            to_u8(implicit)\r\n        )\r\n        needs(nacl.default.sign.detached.verify(m2, sig, this.pk), 'Invalid signature')\r\n        return (new TextDecoder()).decode(msg)\r\n    }\r\n\r\n    /**\r\n     * @param {string} token\r\n     * @returns {Promise<{epk: Uint8Array, tag: Uint8Array, edk: Uint8Array, footer: Uint8Array}>}\r\n     */\r\n    async decompose(token) {\r\n        const header = to_u8(token.slice(0, 10))\r\n        needs(u8_equal(header, V4_PUBLIC_U8), 'Invalid token')\r\n        const tokenPieces = token.split('.')\r\n        const payload = b64u_dec(tokenPieces[2], true)\r\n        const l = payload.length\r\n        return {\r\n            msg: payload.slice(0, l - 64),\r\n            sig: payload.slice(l - 64),\r\n            footer: tokenPieces.length > 3\r\n                ? b64u_dec(tokenPieces[3])\r\n                : new Uint8Array(0)\r\n        }\r\n    }\r\n}\r\n\r\nif (typeof window !== 'undefined') {\r\n    window.PasetoV4Public = PasetoV4Public\r\n}\r\n"],"names":["n","toString","padStart","b64u_chars","b64u_lookup","Uint8Array","i","length","charCodeAt","b64u_dec","base64","as_uint8array","encoded1","encoded2","encoded3","encoded4","bufferLength","len","p","bytes","TextDecoder","decode","b64u_enc","substring","le64","num","needs","Number","isSafeInteger","high","low","out","condition","message","Error","PAE","pieces","piece","to_u8","mixed","tolerate_integers","TextEncoder","encode","u8_equal","a","b","timingSafeEqual","d","V4_PUBLIC","V4_PUBLIC_U8","PasetoV4Public","constructor","pk","sk","this","getSecretKey","getPublicKey","static","keypair","nacl","default","sign","keyPair","publicKey","secretKey","async","token","expected","split","as_object","stored","JSON","parse","from_u8","implicit","verify","claims","footer","stringify","msg_u8","m2","payload","arrs","arr","u8","start","set","u8_concat","detached","slice","join","msg","sig","decompose","tokenPieces","l","window","exports","Object","defineProperty","value"],"mappings":"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"}